## Обфускатор c++
> Обфуска́ция или запутывание кода — приведение исходного текста или исполняемого кода программы к виду, сохраняющему её функциональность, но затрудняющему анализ, понимание алгоритмов работы и модификацию при декомпиляции

Рефакторинг кода с целью обойти простой антиплагиат

### Запуск и использование
Аргументы:
1. Имя входного файла (относительное или абсолютное)
2. -o имя выходного файла. По умолчанию a.cpp (по старой доброй традиции)

Примеры:
```
python3 app/main.py examples/1.cpp

python3 app/main.py examples/2.cpp -o examples/2_out.cpp
```

### Код проходит следующие этапы:
1. Считывание из файла
2. Парсинг или распознавание. Классы, описывающие синтаксис языковых объектов находятся в файле lang_objects.py и начинаются с 
   префикса С, например CFunction - распознает любую функцию, в тч метод класса
3. Превращение сущностей в виде python классов обратно в код, но в измененном виде. За это отвечает метод .refactor()
4. Запись выходного файла

### Как это можно переиспользовать?
1. Кастомизировать обфускаию c++ под свои нужды. Работать с программными сущностями намного проще, чем с сырым кодом
2. Создать свой парсер любого языка с данным обработчиком. Достаточно заменить обработчики в файле lang_objeccts.py
3. Парсинг любых сложных структур описываемых контекстно-свободной грамматикой. Для этого в файле parser_utils.py лежат 
независящие от синтаксиса функции, создающие базу для модификации
4. Генерация кода, на основе разработанной грамматики

Парсер поддерживает основные языковые сущности
- Классы
- Функции
- Импорты
- Выражения
- Условные конструкции
- Объявления переменных
- Структуры

Цель проекта:
- Практика написания простых модулей на python
- Простое решение для помощи людям в лабах по c++ (быстрое первичное изменение рабочего кода, для отправки другим человеком в контест). 
Обратить внимание, что после этого все равно требуется "причесать" выходной код
  